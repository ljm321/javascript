<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型的作用</title>
    <script>

        class Person {
            name = "孙悟空"
            age = 18 

            sayHello() {
                console.log("Hello,我是", this.name)
            }
        }

        class Dog {

        }

        const p = new Person()
        const p2 = new Person()

        const d = new Dog()
        const d2 = new Dog()


        /*
            所有的同类型对象它们的原型对象都是同一个
                vue的组件化编程的原理
              也意味着，同类型对象的原型是一样的

            原型的作用：
                原型就相当于是一个公共的区域，可以被所有该类实例访问，
                    可以将该类实例中，所有的公共属性（方法）统一存储到原型中
                    这样我们只需要创建一个属性，即可被所有实例访问

                JS中继承就是通过原型来实现的
                    当继承时，子类的原型就是一个父类的实例

                        ** 把类当中相同的属性或者方法提取到原型中，让需要使用的类可以访问公共区域的属性或者方法
                        ** 当需要同一个类型的不同对象使用同一个方法时，需要原型
                        ** 多个对象共用一个方法实现数据共享
                        ** object默认是所有类的父类

                在对象中有些值是对象独有的，像属性(name,age,gender)每个对象都应该有自己值，
                    但是有些值对于每个对象来说都是一样的，像各种方法，对于一样的值没必要重复的创建
                    尝试：
                        函数的原型链是什么样子的？
                        Object的原型链是什么样子的？
        */

       // console.log(p)
       // console.log(p2)


        //console.log(p === p2) //false  //两个对象
        //console.log(p.__proto__ === p.__proto__) //true 所有的同类型对象它们的原型对象都是同一个

        class Animal{

        }

        class Cat extends Animal{

        }

        class TomCat extends Cat{

        }

        //const cat = new Cat()

        //上一级的原型就是当前类的父类
        //TomCat --> cat --> Animal实例 --> object --> Object原型 --> null
        //cat --> Animal实例 --> object --> Object原型 --> null
        //p对象 --> object --> Object原型 --> null
        //console.log(cat.__proto__.__proto__.__proto__.__proto__)
    </script>
</head>
<body>
    
</body>
</html>
