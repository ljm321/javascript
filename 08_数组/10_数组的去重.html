<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数组去重</title>
    <script>
        
        /*
            有如下一个数组
                arr = [1,2,1,3,2,4,5,5,6,7]

            编写代码，去除数组中重复的元素 --> [1, 2, 3, 4, 5, 6, 7]
        */

        /*
            如果会算法的话，用线段树或者树状数组的复杂度会低很多 
            Haskell   函数式风格代码
        */

        /*
            首先不要写代码，琢磨不要程序怎么把重复的数据去重
                先把数组的元素逐个列出来  arr[i]  for
                再一次把数组里的元素拿出来与第一次的每一个比较  arr[j] for  if
                如果比较都是同一个位置，那没有意义，避免第一次和第二次在相同的位置比较 j=1+i
                消除重复的数据  splice 
            琢磨事情怎么做，把做这件事的过程列出来
            最后才是把这一过程转化为代码
            写代码才是最后一步，都想明白了才写代码
            把整个过程想清楚，下一步把思路转化代码


        */

        const arr = [1,2,1,3,2,4,5,5,6,7]

        //编写代码去除数组中重复的元素

        // 分别获取数组中的元素
        for(let i=0; i<arr.length; i++){
            //console.log(arr[i])  // 当arr[i]的值为1时 arr[j]的值就要从1往后取，以此类推。避免在相同的位置比较

            //获取当前值后边的所有的值
            for(let j=i+1; j<arr.length; j++){
                //console.log('-->', arr[j])

                //判断两个数是否相等
                if(arr[i] === arr[j]){

                    //出现了重复元素，删除后边的元素
                    arr.splice(j, 1);

                    /*
                        当arr[i] 和 arr[j]相同时，它会自动的删除j位置的元素，然后j+1位置的元素，会变成j位置的元素
                        而j位置已经比较过了，不会重复比较，所以会出现漏比较的情况
                        [1,2,1,3,2,2,4,5,5,6,7]

                        解决办法，当删除一个元素后，需要将该位置的元素在比较一遍
                    */
                   j--; //j--是写在小循环里面的，所以N个重复也会删掉 目的是不跳过元素比较
                };
            };
        };

        console.log(arr);

        /*
            解决一个问题，一般情况下面临的问题，在制定解决方案的时候，可能针对的是某一个具体的问题
                但是，我们的代码最终是希望能处理这一类的问题，所以我们处理这一个问题的时候，一定要尽量去想这类问题当中所有可能出现的情况

                数组中出现的是单个重复的情况 1，1 2，2 特殊情况没有出现如 3，3，3 这样的多个重复数字，所以要考虑这一特殊情况

            ××× 从后往前比较就不用考虑位置缺失的问题

            解决问题很简单，问题是能不能提前发现这一类问题的所有的可能情况
        */
    </script>
</head>
<body>
    
</body>
</html>