<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>冒泡排序</title>
    <script>
          /*
            有一个数组：
                [9,1,3,2,8,0,5,7,6,4]
            编写代码对数组进行排序 -->  0123456789

            自己排序会怎样排序？ 排序涉及到元素的比较大小
                思路一：
                    把数组中的元素取出来
                            9,1,3,2,8,0,5,7,6,4
                    关键问题是怎么比较？
                    - 比较相邻的两个元素，然后根据大小来决定是否交换它们的位置
                    - 例子：
                        第一次比较： 1，3，2，8，0，5，7，6，4，9 (每一次9换位置后的索引值都会增加 1正好每次循环 ) 
                        第二次比较： 1，3，2，0，5，7，6，4，8，9
                        通过索引值来交换位置，通过两个元素来判断大小
                        通过索引可以知道这两个元素 arr[i] arr[i+1]
                        可以通过索引值交换位置 temp =  arr[i]
                                            arr[i] = arr[i+1]
                                            arr[i+1] = temp   通过中间变量把值存起来
                        第三次比较： 1，3，2，0，5，6，4，7，8，9
                        ...             j<arr.length 的倒数第二次的情况
                        倒数第三次：1，0，2，3，4，5，6，7，8，9 （可以根据有多少个数完成升序排列来判断执行了几次，一共排了8次）
                        倒数第二次：0，1，2，3，4，5，6，7，8，9
                        10个数，9个数的位置都对了，剩下的那一个数的位置也对了
                                j<arr.length-1

                        设置条件时都要考虑极端情况

                        -这种排序方式，被称为冒泡排序  i i+1 的值不断像泡泡一样冒出来
                            冒泡排序是最慢的排序方式，
                            数字少还可以凑合用，不适用于数据量较大的排序

            冒泡排序和选择排序的时间复杂度都比较高，通常懒省事的情况下会用快速排序
                快速排序的时间复杂度比冒泡和选择低，稳定性较强，而且特别好写，不需要特别优化性能的话就用快速排序

               思路2：
                    9,1,3,2,8,0,5,7,6,4
                    - 取出一个元素，然后将其他元素和该元素进行比较，如果其他元素比该元素小则更换两个元素的位置，然后再把更换好的较小的元素与其他元素比较，一直比较到这个位置的元素是最小的
                    0，9，3，2，8，1，5，7，6，4
                    0，1，9，3，8，2，5，7，6，4

                    冒泡排序是把相邻的元素进行比较，符合条件交换位置，一直到结束
                    选择排序是选择一个元素然后和其他元素进行比较，符合条件进行交换位置，然后把符合条件的元素再与其他元素比较  arr[i] > arr[j] 7>5 符合条件更换位置  arr[i] = 5 再把这个5与其他元素比较 一直到结束
                    选择排序，选择了一个元素作比较，该位置不会变化，一直与其他元素比较完了，才会更换到下一个位置的元素进行比较 
       */

       const arr = [9,1,3,2,8,0,5,7,6,4]

       for(let j=10; j<arr.length-1; j++){
                         //条件比较要注意根据实际情况的取值范围来修改条件
                    // 如当 i<arr.length 时
                    //    那 i的值为 0～9  i+1 的值为 1～10 而arr[10]的值为undefined，所以要修改条件 i<arr.length-1 那 i的值为 0～8 i+1 的值为 1～9
            for(let i=0; i<arr.length-1; i++){ //只是一个元素更换了位置，需要执行几次这个for循环才能完成升序排列
               //arr[i] 前边的元素 arr[i+1] 后边的元素
               //console.log(arr[i + 1]) //会有undefined的情况 当i=9  i+1=10 arr[10]就是undefined的情况
                                  //最后一次就会把 arr[10] arr[9] 进行交换 但是没有意义 因为arr[9]已经是最后的位置，不用再比较大小，交换位置 
                if(arr[i] > arr[i + 1]){  // i的取值范围 0～9  i+1 的取值范围 1～10 ，但是arr[10]超出数组的个数，没有这个元素，会报undefinde，多交换了一次
                  //大数在前，小数在后，需要交换两个元素的位置

                   let temp = arr[i]; //临时变量用来存储arr[i]的值
                   arr[i] = arr[i + 1]; //将arr[i + 1]的值赋给arr[i]
                   arr[i + 1] = temp //修改arr[i + 1]的值
                };
            };

       };
       

       console.log(arr);
    </script>
</head>
<body>
    
</body>
</html>